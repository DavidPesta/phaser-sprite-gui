// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";
  var Phaser, SpriteGUI,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Phaser = this.Phaser;

  this.SpriteGUI = Object.freeze(SpriteGUI = (function(superClass) {
    var addAnchor, addAnim, addBody, addInput, addPoint, addRect, addScale, createMap;

    extend(SpriteGUI, superClass);

    SpriteGUI.addAnchor = addAnchor = function(cn, anchor) {
      addPoint(cn, anchor, 0, 1, 0.1);
      return cn;
    };

    SpriteGUI.addAnim = addAnim = function(cn, anim) {
      cn.add(anim, "paused").listen();
      cn.add(anim, "updateIfVisible").listen();
      return cn;
    };

    SpriteGUI.addBody = addBody = function(cn, body) {
      cn.add(body, "allowGravity");
      cn.add(body, "allowRotation");
      cn.add(body, "angularAcceleration", -body.maxAngular, body.maxAngular, 10).listen();
      cn.add(body, "angularDrag", 0, 2 * body.maxAngular, 10).listen();
      cn.add(body, "angularVelocity", -body.maxAngular, body.maxAngular, 10).listen();
      addPoint(cn.addFolder("bounce"), body.bounce, 0, 1, 0.1);
      cn.add(body, "collideWorldBounds").listen();
      addPoint(cn.addFolder("drag"), body.drag, 0, 1000, 10);
      cn.add(body, "enable").listen();
      addPoint(cn.addFolder("friction"), body.friction, 0, 1, 0.1);
      addPoint(cn.addFolder("gravity"), body.gravity, -1000, 1000, 100);
      cn.add(body, "immovable").listen();
      cn.add(body, "mass", 0.5, 10, 0.5).listen();
      cn.add(body, "maxAngular", 0, 1000, 10).listen();
      addPoint(cn.addFolder("maxVelocity"), body.maxVelocity, 0, 1000, 10);
      cn.add(body, "moves").listen();
      addPoint(cn.addFolder("offset"), body.offset);
      cn.add(body, "rotation", -180, 180, 5).listen();
      cn.add(body, "skipQuadTree").listen();
      cn.add(body, "syncBounds").listen();
      addPoint(cn.addFolder("velocity"), body.velocity, -1000, 1000, 10);
      return cn;
    };

    SpriteGUI.addInput = addInput = function(cn, input) {
      cn.add(input, "allowHorizontalDrag").listen();
      cn.add(input, "allowVerticalDrag").listen();
      if (input.boundsRect) {
        addRect(cn.addFolder("boundsRect"), input.boundsRect);
      }
      cn.add(input, "dragDistanceThreshold", 0, 10, 1).listen();
      cn.add(input, "draggable").listen();
      addPoint(cn.addFolder("dragOffset"), input.dragOffset, 0, 100);
      cn.add(input, "dragStopBlocksInputUp").listen();
      cn.add(input, "dragTimeThreshold", 0, 100, 10).listen();
      cn.add(input, "bringToTop").listen();
      cn.add(input, "enabled").listen();
      cn.add(input, "pixelPerfectAlpha", 0, 255, 5).listen();
      cn.add(input, "pixelPerfectClick").listen();
      cn.add(input, "pixelPerfectOver").listen();
      cn.add(input, "priorityID", 0, 10, 1).listen();
      cn.add(input, "reset");
      cn.add(input, "snapOffsetX", -100, 100, 10).listen();
      cn.add(input, "snapOffsetY", -100, 100, 10).listen();
      cn.add(input, "snapOnDrag").listen();
      cn.add(input, "snapOnRelease").listen();
      cn.add(input, "snapX", 0, 100, 5).listen();
      cn.add(input, "snapY", 0, 100, 5).listen();
      cn.add(input, "stop");
      cn.add(input, "useHandCursor").listen();
      return cn;
    };

    SpriteGUI.addPoint = addPoint = function(cn, point, min, max, step) {
      cn.add(point, "x", min, max, step).listen();
      cn.add(point, "y", min, max, step).listen();
      return cn;
    };

    SpriteGUI.addRect = addRect = function(cn, rect, min, max, step) {
      if (min == null) {
        min = 0;
      }
      if (max == null) {
        max = 1000;
      }
      if (step == null) {
        step = 10;
      }
      cn.add(rect, "x", min, max, step).listen();
      cn.add(rect, "y", min, max, step).listen();
      cn.add(rect, "width", min, max, step).listen();
      cn.add(rect, "height", min, max, step).listen();
      return cn;
    };

    SpriteGUI.addScale = addScale = function(cn, scale, min, max) {
      addPoint(cn, scale, min, max);
      return cn;
    };

    SpriteGUI.createMap = createMap = function(arr) {
      var i, key, len, map;
      map = {};
      for (i = 0, len = arr.length; i < len; i++) {
        key = arr[i];
        map[key] = true;
      }
      return map;
    };

    SpriteGUI.prototype.exclude = null;

    SpriteGUI.prototype.include = null;

    function SpriteGUI(sprite1, params, options) {
      this.sprite = sprite1;
      if (params == null) {
        params = {};
      }
      if (options == null) {
        options = {};
      }
      SpriteGUI.__super__.constructor.call(this, params);
      if (options) {
        if (options.include) {
          this.include = createMap(options.include);
          this.filter = this.filterInclude;
        } else if (options.exclude) {
          this.exclude = createMap(options.exclude);
          this.filter = this.filterExclude;
        }
      }
      this.addAll();
    }

    SpriteGUI.prototype.add = function(obj, prop) {
      if (!this.filter(prop)) {
        return;
      }
      if (obj[prop] === null) {
        console.warn("Property '" + prop + "' is null");
      } else {
        return SpriteGUI.__super__.add.apply(this, arguments);
      }
    };

    SpriteGUI.prototype.listenTo = function(obj, prop) {
      var result;
      result = this.add.apply(this, arguments);
      if (result) {
        return result.listen();
      } else {
        return result;
      }
    };

    SpriteGUI.prototype.addAll = function() {
      var animations, bounds, sprite, world;
      sprite = this.sprite;
      world = sprite.game.world;
      bounds = world.bounds;
      animations = sprite.animations;
      this.listenTo(sprite, "alive");
      this.listenTo(sprite, "alpha", 0, 1);
      this.listenTo(sprite, "autoCull");
      if ((animations != null ? animations.frameTotal : void 0) > 1) {
        this.addAnim();
      }
      this.addAnchor();
      this.listenTo(sprite, "blendMode", Phaser.blendModes);
      this.add(sprite, "bringToTop");
      if (sprite.body && sprite.body.type === Phaser.Physics.ARCADE) {
        this.addBody();
      }
      this.listenTo(sprite, "cacheAsBitmap");
      this.addPoint("cameraOffset", sprite.cameraOffset);
      this.listenTo(sprite, "checkWorldBounds");
      this.listenTo(sprite, "debug");
      this.listenTo(sprite, "exists");
      this.listenTo(sprite, "fixedToCamera");
      this.listenTo(sprite, "frame", animations.frameData.getFrameIndexes());
      this.listenTo(sprite, "frameName");
      this.listenTo(sprite, "health", 0, sprite.maxHealth);
      if (sprite.input) {
        this.addInput();
      }
      this.listenTo(sprite, "key");
      this.add(sprite, "kill");
      this.listenTo(sprite, "lifespan", 0, 10000, 100);
      this.add(sprite, "moveDown");
      this.add(sprite, "moveUp");
      this.listenTo(sprite, "name");
      this.listenTo(sprite, "outOfBoundsKill");
      this.listenTo(sprite, "outOfCameraBoundsKill");
      this.listenTo(sprite, "renderable");
      this.add(sprite, "reset");
      this.add(sprite, "revive");
      this.listenTo(sprite, "rotation", -Math.PI, Math.PI, Math.PI / 30);
      this.add(sprite, "sendToBack");
      this.addScale();
      this.listenTo(sprite, "smoothed");
      this.listenTo(sprite, "tint");
      this.listenTo(sprite, "visible");
      this.listenTo(sprite, "x", world.bounds.left, world.bounds.right);
      this.listenTo(sprite, "y", world.bounds.top, world.bounds.bottom);
      this.listenTo(sprite, "z");
    };

    SpriteGUI.prototype.addAnchor = function() {
      if (this.filter("anchor")) {
        return addAnchor(this.addFolder("anchor"), this.sprite.anchor);
      }
    };

    SpriteGUI.prototype.addAnim = function() {
      if (this.filter("animations")) {
        return addAnim(this.addFolder("animations"), this.sprite.animations);
      }
    };

    SpriteGUI.prototype.addBody = function() {
      if (this.filter("body")) {
        return addBody(this.addFolder("body"), this.sprite.body);
      }
    };

    SpriteGUI.prototype.addInput = function() {
      if (this.filter("input")) {
        return addInput(this.addFolder("input"), this.sprite.input);
      }
    };

    SpriteGUI.prototype.addPoint = function(name, point, min, max, step) {
      return addPoint(this.addFolder(name), point, min, max, step);
    };

    SpriteGUI.prototype.addScale = function() {
      if (this.filter("scale")) {
        return addScale(this.addFolder("scale"), this.sprite.scale, this.sprite.scaleMin || -5, this.sprite.scaleMax || 5);
      }
    };

    SpriteGUI.prototype.filter = function() {
      return true;
    };

    SpriteGUI.prototype.filterExclude = function(name) {
      console.log((this.exclude[name] && 'skip' || 'keep') + " " + name);
      return !this.exclude[name];
    };

    SpriteGUI.prototype.filterInclude = function(name) {
      console.log((this.include[name] && 'keep' || 'skip') + " " + name);
      return this.include[name];
    };

    return SpriteGUI;

  })(dat.GUI));

}).call(this);
